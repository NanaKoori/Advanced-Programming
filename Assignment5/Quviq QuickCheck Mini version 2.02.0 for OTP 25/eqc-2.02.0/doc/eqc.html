<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module eqc</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eqc</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module defines functions for writing and testing QuickCheck properties.
<p>Copyright Â© Quviq AB, 2004-2022</p>

<p><b>Version:</b> 2.02.0</p>

<h2><a name="description">Description</a></h2>This module defines functions for writing and testing QuickCheck properties.
 Much of the interface is provided via macros (defined in <tt>eqc.hrl</tt>).
 These are documented below:
 <h2><tt>?FORALL(X,Gen,Prop)</tt></h2>
 Property that holds if <tt>Prop</tt> holds for all values <tt>X</tt> that
 can be generated by <tt>Gen</tt>. For example,
 <pre>
 prop_reverse() -&gt;
   ?FORALL(Xs,list(int()),
      lists:reverse(lists:reverse(Xs)) == Xs).
 </pre>
 Generators are defined using the module <a docgen-rel="seeerl" docgen-href="eqc_gen" href="eqc_gen.html"><code>eqc_gen</code></a>.
 <h2><tt>?IMPLIES(Pre,Prop)</tt></h2>
 Property that holds if <tt>Prop</tt> holds whenever the precondition
 <tt>Pre</tt> is true. The precondition must be a boolean, but <tt>Prop</tt>
 can be any QuickCheck property. An implication is tested by discarding test
 cases which do not satisfy the precondition. This can make testing slow,
 since many more test cases may need to be generated to find 100 which
 satisfy the precondition. In the worst case, QuickCheck may not be able
 to find enough test cases that do satisfy the precondition, in which case
 the number actually found is reported. Some preconditions may also skew
 the test data badly--for example, a precondition that a list is sorted
 skews the test data towards short lists, since random longer lists are
 extremely unlikely to be sorted just by chance. <tt>?IMPLIES</tt> works
 well for preconditions which are true with a high probability, but if the
 precondition is unlikely to hold, then it is better to write a custom
 generator which generates test cases where the precondition is true.
 <h2><tt>?WHENFAIL(Action,Prop)</tt></h2>
 Property that is equivalent to <tt>Prop</tt>, but performs <tt>Action</tt>
 (for its side effects) when <tt>Prop</tt> fails. This can be used to
 print additional information when a test case fails.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-aggregated_data">aggregated_data()</a></h3>
<p><tt>aggregated_data() = [{term(), integer()}]</tt></p>
<p> Aggregated data, in principle a map from terms to number of occurences.</p>

<h3 class="typedecl"><a name="type-counterexample">counterexample()</a></h3>
<p><b>abstract datatype</b>: <tt>counterexample()</tt></p>
<p> A counter-example to a QuickCheck property, which can be obtained
 using  <a docgen-rel="seemfa" docgen-href="#counterexample/0" href="#counterexample-0"><code>counterexample/0</code></a> or <a docgen-rel="seemfa" docgen-href="#counterexample/1" href="#counterexample-1"><code>counterexample/1</code></a>, and used to repeat a test,
 or test a different property in the same case. Counterexamples are represented by the values
 bound by ?FORALL--for the counterexample to make sense independently, it's important that
 these were generated without side-effects.</p>

<h3 class="typedecl"><a name="type-eqc_info_map">eqc_info_map()</a></h3>
<p><tt>eqc_info_map() = #{result =&gt; boolean() | <a href="#type-counterexample">counterexample()</a>, statistics =&gt; #{outcome =&gt; passed | failed | failed_as_expected | passed_unexpectedly | gaveup | bad_distribution, numtests =&gt; integer(), discards =&gt; integer()}, aggregated_data =&gt; [{atom(), <a href="#type-aggregated_data">aggregated_data()</a>}], measurements =&gt; [{atom(), <a href="#type-measure_map">measure_map()</a>}], user_info =&gt; <a href="#type-eqc_user_info_map">eqc_user_info_map()</a>}</tt></p>


<h3 class="typedecl"><a name="type-eqc_user_info_map">eqc_user_info_map()</a></h3>
<p><tt>eqc_user_info_map() = #{}</tt></p>
<p><p> Map containing user defined data. Data is stored using <a docgen-rel="seemfa" docgen-href="#user_info/3" href="#user_info-3"><code>user_info/3</code></a>, and the result 
is a map with all keys defined by the user.</p>

 I.e. user_info(key1, data1, ...) will result in a map #{ key1 =&gt; data1, ... }.</p>

<h3 class="typedecl"><a name="type-measure_map">measure_map()</a></h3>
<p><tt>measure_map() = #{count =&gt; integer(), min =&gt; number(), max =&gt; number(), sum =&gt; number(), avg =&gt; number(), stddev =&gt; number()}</tt></p>
<p> Map containing the returned data collected by <a docgen-rel="seemfa" docgen-href="#measure/3" href="#measure-3"><code>measure/3</code></a>.</p>

<h3 class="typedecl"><a name="type-print_method">print_method()</a></h3>
<p><tt>print_method() = <a href="#type-print_method_fun">print_method_fun()</a> | {atom() | string(), none | string(), <a href="#type-print_method_fun">print_method_fun()</a>}</tt></p>
<p> Instructions on how to print statistics; either a pure <a docgen-rel="seeerl" docgen-href="print_method_fun" href="print_method_fun.html"><code>print_method_fun</code></a>
 (the old way), or a triple {Tag, Title, PrintFun}. Where Tag is used to
 tag the returned statistics see <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a>, Title is printed as
 a header for the statistics printed by PrintFun.
 Used by <a docgen-rel="seemfa" docgen-href="#collect/3" href="#collect-3"><code>collect/3</code></a> and <a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="typedecl"><a name="type-print_method_fun">print_method_fun()</a></h3>
<p><tt>print_method_fun() = fun((<a href="#type-aggregated_data">aggregated_data()</a>) -&gt; false | any())</tt></p>
<p> Printing statistics, the function is passed a list of samples and is
 expected to print statistical information about them. Print functions
 are used by <a docgen-rel="seemfa" docgen-href="#collect/3" href="#collect-3"><code>collect/3</code></a> and <a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="typedecl"><a name="type-property">property()</a></h3>
<p><b>abstract datatype</b>: <tt>property()</tt></p>
<p> QuickCheck properties, which can either be boolean
 expressions, or constructed using the functions in this module.
 QuickCheck properties are tested using <a docgen-rel="seemfa" docgen-href="#quickcheck/1" href="#quickcheck-1"><code>quickcheck/1</code></a>.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#aggregate-2">aggregate/2</a></td><td>A property logically equivalent to <tt>Prop</tt>, but which collects a list of values in
 each test, and displays the distribution of these values once
 testing is complete.</td></tr>
<tr><td valign="top"><a href="#aggregate-3">aggregate/3</a></td><td>Like <a docgen-rel="seemfa" docgen-href="#aggregate/2" href="#aggregate-2"><code>aggregate/2</code></a>, but allows the user to specify how
 the collected values should be printed.</td></tr>
<tr><td valign="top"><a href="#check-1">check/1</a></td><td>Equivalent to <a href="#check-2"><tt>check(Prop, eqc:current_counterexample())</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#check-2">check/2</a></td><td>Tests the property in the case given.</td></tr>
<tr><td valign="top"><a href="#check-3">check/3</a></td><td>Tests the property in the case given.</td></tr>
<tr><td valign="top"><a href="#check_distribution-4">check_distribution/4</a></td><td>Check that at least a given fraction of test cases satisfy a condition.</td></tr>
<tr><td valign="top"><a href="#classify-3">classify/3</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but also
 classifies test cases and displays the distribution of test case classes
 when testing is complete.</td></tr>
<tr><td valign="top"><a href="#collect-2">collect/2</a></td><td>Equivalent to <a href="#aggregate-2"><tt>aggregate([S], Prop)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#collect-3">collect/3</a></td><td>Equivalent to <a href="#aggregate-3"><tt>aggregate(PrintMethod, [S], Prop)</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#counterexample-0">counterexample/0</a></td><td>Returns the last counter-example found.</td></tr>
<tr><td valign="top"><a href="#counterexample-1">counterexample/1</a></td><td>Equivalent to <a href="#counterexample-2"><tt>counterexample(P, [])</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#counterexample-2">counterexample/2</a></td><td>Tests the property in the same way as <a docgen-rel="seemfa" docgen-href="#quickcheck/1" href="#quickcheck-1"><code>quickcheck/1</code></a>, but if 
a test fails, then the failing test case is returned as a counterexample.</td></tr>
<tr><td valign="top"><a href="#counterexamples-0">counterexamples/0</a></td><td>Returns a list of the counterexamples found by the last call
  of <code>eqc:module</code>, paired with the name of the property that failed.</td></tr>
<tr><td valign="top"><a href="#equals-2">equals/2</a></td><td>A property which holds if X and Y are equal...</td></tr>
<tr><td valign="top"><a href="#fails-1">fails/1</a></td><td>A property which succeeds when its argument fails.</td></tr>
<tr><td valign="top"><a href="#format-2">format/2</a></td><td>Can be used in place of <tt>io:format/2</tt> inside <tt>?WHENFAIL</tt>
  to allow the output to be captured by <tt>on_output/2</tt>.</td></tr>
<tr><td valign="top"><a href="#in_parallel-1">in_parallel/1</a></td><td>A property which is tested in parallel.</td></tr>
<tr><td valign="top"><a href="#in_sequence-1">in_sequence/1</a></td><td>A property which is tested sequentially.</td></tr>
<tr><td valign="top"><a href="#less_or_equal-2">less_or_equal/2</a></td><td>A property which holds if <tt>X =&lt; Y</tt>, and displays
 their values when a test fails.</td></tr>
<tr><td valign="top"><a href="#measure-3">measure/3</a></td><td>Collects the values of X while testing Prop, and if all tests
 pass, displays statistics such as the minimum, average, and maximum
 values, identified by the name Name.</td></tr>
<tr><td valign="top"><a href="#module-1">module/1</a></td><td>Tests all the properties exported from a module, given the module name.</td></tr>
<tr><td valign="top"><a href="#numtests-2">numtests/2</a></td><td>Property which is logically equivalent to <tt>Prop</tt>, but is
 tested <tt>N</tt> times rather than 100.</td></tr>
<tr><td valign="top"><a href="#on_output-2">on_output/2</a></td><td>Supplies an output function to be used instead of io:format
  when QuickCheck generates output.</td></tr>
<tr><td valign="top"><a href="#on_test-2">on_test/2</a></td><td>Attaches a function to a property which is called every time a
  test passes or fails.</td></tr>
<tr><td valign="top"><a href="#only_top-1">only_top/1</a></td><td>A printing method for discarding all but the top N collected values.</td></tr>
<tr><td valign="top"><a href="#only_top-2">only_top/2</a></td><td>A printing method for discarding all but the top N collected values.</td></tr>
<tr><td valign="top"><a href="#quickcheck-1">quickcheck/1</a></td><td>Tests the property in 100 random cases, printing a counter-example
 if one is found.</td></tr>
<tr><td valign="top"><a href="#recheck-1">recheck/1</a></td><td>Tests the property with the <i>same</i> random number seed as
 the last failing call of <a docgen-rel="seemfa" docgen-href="#quickcheck/1" href="#quickcheck-1"><code>quickcheck/1</code></a>.</td></tr>
<tr><td valign="top"><a href="#recheck-2">recheck/2</a></td><td>Same as <a docgen-rel="seemfa" docgen-href="#recheck/1" href="#recheck-1"><code>recheck/1</code></a>, but if {with_info, true} is passed as an option
 a richer structure is returned.</td></tr>
<tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the QuickCheck server.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Equivalent to <a href="#start-0"><tt>start()</tt></a>.
</td></tr>
<tr><td valign="top"><a href="#stop-0">stop/0</a></td><td>Stops the QuickCheck server.</td></tr>
<tr><td valign="top"><a href="#user_info-3">user_info/3</a></td><td>Sometimes it is useful to record data deep inside a property, thus we
 provide a basic key-value store.</td></tr>
<tr><td valign="top"><a href="#version-0">version/0</a></td><td>Returns the version number of this version of QuickCheck.</td></tr>
<tr><td valign="top"><a href="#with_tag-1">with_tag/1</a></td><td>A printing method for collected data, which tags the collected
  data so that it is returned in the rich result structure from
  <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#with_title-1">with_title/1</a></td><td>A printing method for collected data, which displays a title
  before the percentages of each value in the data.</td></tr>
<tr><td valign="top"><a href="#with_title-2">with_title/2</a></td><td>Add a title to a print method.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="aggregate-2">aggregate/2</a></h3>
<div class="spec">
<p><tt>aggregate(L::[term()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>A property logically equivalent to <tt>Prop</tt>, but which collects a list of values in
 each test, and displays the distribution of these values once
 testing is complete. A typical use would be to aggregate the list of command names generated
 by <a docgen-rel="seemfa" docgen-href="eqc_statem#commands/1" href="eqc_statem.html#commands-1"><code>eqc_statem:commands/1</code></a>, in order to see how often each individual
 command appeared in generated tests:
 <pre>aggregate(command_names(Cmds), ...) </pre>
 <p>
 See also <a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>.
 </p></p>

<h3 class="function"><a name="aggregate-3">aggregate/3</a></h3>
<div class="spec">
<p><tt>aggregate(PrintMethod::fun(([{term(), <a href="#type-int">int()</a>}]) -&gt; any()), L::[term()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Like <a docgen-rel="seemfa" docgen-href="#aggregate/2" href="#aggregate-2"><code>aggregate/2</code></a>, but allows the user to specify how
 the collected values should be printed. The <tt>PrintMethod</tt> parameter
 is called with a list of the collected data and the number of occurrences of each datum as an argument,
 and is expected to print some statistics. If the print method returns
 <tt>false</tt> the property fails. This is used in the implementation of
 <a docgen-rel="seemfa" docgen-href="#check_distribution/4" href="#check_distribution-4"><code>check_distribution/4</code></a>.
 A predefined printing
 methods is provided to add a title to the statistics:
 <pre>aggregate(with_title(T),L,Prop).</pre> This is useful when a property contains
 several calls to aggregate or collect.</p>

<h3 class="function"><a name="check-1">check/1</a></h3>
<div class="spec">
<p><tt>check(Prop) -&gt; any()</tt></p>
<p> </p>
</div><p>Equivalent to <a href="#check-2"><tt>check(Prop, eqc:current_counterexample())</tt></a>.</p>


<h3 class="function"><a name="check-2">check/2</a></h3>
<div class="spec">
<p><tt>check(Prop::<a href="#type-property">property()</a>, Values::<a href="#type-counterexample">counterexample()</a>) -&gt; bool()</tt><br></p>
<p> </p>
</div><p>Tests the property in the case given. Counterexamples are generated by testing a
 property using <a docgen-rel="seemfa" docgen-href="#counterexample/1" href="#counterexample-1"><code>counterexample/1</code></a> or <a docgen-rel="seemfa" docgen-href="#counterexample/0" href="#counterexample-0"><code>counterexample/0</code></a>, and contain a list
 of the values bound by ?FORALL. A property tested by check should begin with the <i>same</i>
 sequence of ?FORALL s as the property from which the counterexample was generated, otherwise
 the results will be unpredictable. In particular, there is no check that the values
 in the counterexample could actually have been generated by the ?FORALL s in the property under
 test.
 <p><a docgen-rel="seemfa" docgen-href="#check/2" href="#check-2"><code>check/2</code></a> can be used without a QuickCheck licence, allowing anyone to run
 tests that a licenced user has generated.</p></p>

<h3 class="function"><a name="check-3">check/3</a></h3>
<div class="spec">
<p><tt>check(Prop::<a href="#type-property">property()</a>, Values::<a href="#type-counterexample">counterexample()</a>, Options::[term()]) -&gt; bool() | <a href="#type-eqc_info_map">eqc_info_map()</a></tt><br></p>
<p> </p>
</div><p><p>Tests the property in the case given. Counterexamples are generated by testing a
 property using <a docgen-rel="seemfa" docgen-href="#counterexample/1" href="#counterexample-1"><code>counterexample/1</code></a> or <a docgen-rel="seemfa" docgen-href="#counterexample/0" href="#counterexample-0"><code>counterexample/0</code></a>, and contain a list
 of the values bound by ?FORALL. A property tested by check should begin with the <i>same</i>
 sequence of ?FORALL s as the property from which the counterexample was generated, otherwise
 the results will be unpredictable. In particular, there is no check that the values
 in the counterexample could actually have been generated by the ?FORALL s in the property under
 test. If <tt>{with_info, true}</tt> is passed as an Option, a richer structure is
 returned, see <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a>.</p>

 <p><a docgen-rel="seemfa" docgen-href="#check/3" href="#check-3"><code>check/3</code></a> can be used without a QuickCheck licence, allowing anyone to run
 tests that a licenced user has generated.</p></p>

<h3 class="function"><a name="check_distribution-4">check_distribution/4</a></h3>
<div class="spec">
<p><tt>check_distribution(Tag::term(), Fraction::float(), Ok::boolean() | [boolean()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Check that at least a given fraction of test cases satisfy a condition.
 Unless <tt>Ok</tt> is true in at least <tt>Fraction</tt> of test cases the property fails.
 For instance, <pre>check_distribution(non_empty, 0.75, Xs /= [], Prop)</pre>
 checks that in at least 75% of test cases the list <tt>Xs</tt> is non empty. If <tt>Ok</tt>
 is a list, the distribution of the aggregated boolean values is checked (see <a docgen-rel="seemfa" docgen-href="#aggregate/2" href="#aggregate-2"><code>aggregate/2</code></a>).</p>

<h3 class="function"><a name="classify-3">classify/3</a></h3>
<div class="spec">
<p><tt>classify(B::bool(), S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but also
 classifies test cases and displays the distribution of test case classes
 when testing is complete. If the boolean is true then the current test case is
 labelled with the term <tt>S</tt>,
 and, after testing is complete, QuickCheck prints out the percentage of
 test cases carrying each label. This can be used to check that the space
 of possible test cases has been covered reasonably well. For example,
 classifying test cases according to the length of a list enables one to
 see whether unreasonably many lists were short. Classifying
 test cases is a way to discover skewed distributions, such as can arise
 from using <tt>?IMPLIES</tt>. It is good practice to check the distribution
 of test data using <tt>classify</tt> or <a docgen-rel="seemfa" docgen-href="#collect/2" href="#collect-2"><code>collect/2</code></a>, at least while
 properties are being developed.
 <p>
 Each test case can be labelled with any number of labels: QuickCheck then
 displays the percentage of each label in the generated
 test data.
 </p>
 <p>
 Calls of classify or collect can be nested, in which case each call
 generates its own table of distributions.
 </p></p>

<h3 class="function"><a name="collect-2">collect/2</a></h3>
<div class="spec">
<p><tt>collect(S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Equivalent to <a href="#aggregate-2"><tt>aggregate([S], Prop)</tt></a>.</p>


<h3 class="function"><a name="collect-3">collect/3</a></h3>
<div class="spec">
<p><tt>collect(PrintMethod::fun(([{term(), <a href="#type-int">int()</a>}]) -&gt; any()), S::term(), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Equivalent to <a href="#aggregate-3"><tt>aggregate(PrintMethod, [S], Prop)</tt></a>.</p>


<h3 class="function"><a name="counterexample-0">counterexample/0</a></h3>
<div class="spec">
<p><tt>counterexample() -&gt; undefined | <a href="#type-counterexample">counterexample()</a></tt><br></p>
<p> </p>
</div><p>Returns the last counter-example found. See <a docgen-rel="seemfa" docgen-href="#counterexample/1" href="#counterexample-1"><code>counterexample/1</code></a>.</p>

<h3 class="function"><a name="counterexample-1">counterexample/1</a></h3>
<div class="spec">
<p><tt>counterexample(P::<a href="#type-property">property()</a>) -&gt; true | <a href="#type-counterexample">counterexample()</a></tt><br></p>
<p> </p>
</div><p>Equivalent to <a href="#counterexample-2"><tt>counterexample(P, [])</tt></a>.</p>


<h3 class="function"><a name="counterexample-2">counterexample/2</a></h3>
<div class="spec">
<p><tt>counterexample(P::<a href="#type-property">property()</a>, Option::[term()]) -&gt; true | <a href="#type-counterexample">counterexample()</a> | <a href="#type-eqc_info_map">eqc_info_map()</a></tt><br></p>
<p> </p>
</div><p><p>Tests the property in the same way as <a docgen-rel="seemfa" docgen-href="#quickcheck/1" href="#quickcheck-1"><code>quickcheck/1</code></a>, but if 
a test fails, then the failing test case is returned as a counterexample.</p>

 If <tt>{with_info, true}</tt> is passed as an option, an even richer structure
 is returned, namely an <a docgen-rel="seeerl" docgen-href="eqc_info_map" href="eqc_info_map.html"><code>eqc_info_map</code></a>. The returned map contains the
 following fields:
 <ul>
 <li><b>result -</b> what <a docgen-rel="seemfa" docgen-href="#counterexample/1" href="#counterexample-1"><code>counterexample/1</code></a> would return</li>
 <li><b>statistics -</b> A map containing, <tt>outcome</tt> of the test as well as the number of executed
 tests (<tt>numtests</tt>) and discarded tests (<tt>discards</tt>). If the test fails
 it also contains successful shrink steps (<tt>shrinksteps</tt>) and failed shrink steps
 (<tt>failed_shrinksteps</tt>).</li>
 <li><b>aggregated_data -</b> all aggregated data (<a docgen-rel="seemfa" docgen-href="#collect/3" href="#collect-3"><code>collect/3</code></a>/<a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>/<a docgen-rel="seemfa" docgen-href="#classify/3" href="#classify-3"><code>classify/3</code></a>)
 that has a tag is put into this field. Aggregated data is tagged by using <a docgen-rel="seemfa" docgen-href="#with_tag/1" href="#with_tag-1"><code>with_tag/1</code></a>
 or <a docgen-rel="seeerl" docgen-href="with_title" href="with_title.html"><code>with_title</code></a> as its print method.</li>
 <li><b>measurements -</b> Data collected by <a docgen-rel="seemfa" docgen-href="#measure/3" href="#measure-3"><code>measure/3</code></a>, formatted as a <a docgen-rel="seeerl" docgen-href="measure_map" href="measure_map.html"><code>measure_map</code></a>.</li>
 <li><b>user_info -</b> Data collected by ?USER_INFO in the property, format is a <a docgen-rel="seeerl" docgen-href="eqc_user_info_map" href="eqc_user_info_map.html"><code>eqc_user_info_map</code></a>.</li>
 </ul></p>

<h3 class="function"><a name="counterexamples-0">counterexamples/0</a></h3>
<div class="spec">
<p><tt>counterexamples() -&gt; [{atom(), <a href="#type-counterexample">counterexample()</a>}]</tt><br></p>
<p> </p>
</div><p>Returns a list of the counterexamples found by the last call
  of <code>eqc:module</code>, paired with the name of the property that failed.</p>

<h3 class="function"><a name="equals-2">equals/2</a></h3>
<div class="spec">
<p><tt>equals(X::any(), Y::any()) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>A property which holds if X and Y are equal... and displays
 their values when a test fails.</p>

<h3 class="function"><a name="fails-1">fails/1</a></h3>
<div class="spec">
<p><tt>fails(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>A property which succeeds when its argument fails.
 Sometimes it is useful to write down properties which do <i>not</i> hold
 (even though one might expect them to). This can help prevent misconceptions.
 <tt>fails(P)</tt> is tested in the same way as <tt>P</tt>, but
 fails only if <tt>P</tt> <i>succeeds</i> for every test. Thus
 <tt>fails(P)</tt> declares that QuickCheck should be able to find
 a counter-example to property <tt>P</tt>.</p>

<h3 class="function"><a name="format-2">format/2</a></h3>
<div class="spec">
<p><tt>format(Fmt::string(), Args::[term()]) -&gt; ok</tt><br></p>
<p> </p>
</div><p>Can be used in place of <tt>io:format/2</tt> inside <tt>?WHENFAIL</tt>
  to allow the output to be captured by <tt>on_output/2</tt>.</p>

<h3 class="function"><a name="in_parallel-1">in_parallel/1</a></h3>
<div class="spec">
<p><tt>in_parallel(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>A property which is tested in parallel.</p>

<h3 class="function"><a name="in_sequence-1">in_sequence/1</a></h3>
<div class="spec">
<p><tt>in_sequence(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>A property which is tested sequentially. Takes priority over <a docgen-rel="seemfa" docgen-href="#in_parallel/1" href="#in_parallel-1"><code>in_parallel/1</code></a>.</p>

<h3 class="function"><a name="less_or_equal-2">less_or_equal/2</a></h3>
<div class="spec">
<p><tt>less_or_equal(X::any(), Y::any()) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>A property which holds if <tt>X =&lt; Y</tt>, and displays
 their values when a test fails.</p>

<h3 class="function"><a name="measure-3">measure/3</a></h3>
<div class="spec">
<p><tt>measure(Name::atom() | string(), X::number() | [number()], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Collects the values of X while testing Prop, and if all tests
 pass, displays statistics such as the minimum, average, and maximum
 values, identified by the name Name. X can also be a list of values,
 in which case all of them are included in the measurements.</p>

<h3 class="function"><a name="module-1">module/1</a></h3>
<div class="spec">
<p><tt>module(Mod::atom()) -&gt; [atom()]</tt><br></p>
<p> </p>
</div><p>Tests all the properties exported from a module, given the module name.
 Any function with arity zero whose name begins with "prop_" is treated as a
 property. The result is a list of the names of the properties that
 failed. See also <a docgen-rel="seemfa" docgen-href="#module/2" href="#module-2"><code>module/2</code></a>.</p>

<h3 class="function"><a name="numtests-2">numtests/2</a></h3>
<div class="spec">
<p><tt>numtests(N::<a href="#type-nat">nat()</a>, Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Property which is logically equivalent to <tt>Prop</tt>, but is
 tested <tt>N</tt> times rather than 100.
  <p>It is also possible to specify <tt>{min,N}</tt> or
  <tt>{max,N}</tt> as the number of tests, in which case we run
  <i>at least</i> <tt>N</tt> tests, or <i>at most</i>
  <tt>N</tt> tests, but otherwise according to the time limits or
  <a docgen-rel="seemfa" docgen-href="#numtests/2" href="#numtests-2"><code>numtests/2</code></a> specified in the rest of the property.</p></p>

<h3 class="function"><a name="on_output-2">on_output/2</a></h3>
<div class="spec">
<p><tt>on_output(Fun::fun((string(), [term()]) -&gt; any()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Supplies an output function to be used instead of io:format
  when QuickCheck generates output. All output generated by
  QuickCheck is passed to <tt>Fun</tt>, in the form of a format
  string and a list of terms--the same arguments expected by
  <tt>io:format</tt>. By supplying a function which does nothing,
  QuickCheck can be run silently. By supplying a function which
  writes to a file, all QuickCheck output can be saved.
  <p>Note that output generated by user code is <i>not</i> passed to
  this output function. For example, calls to io:format in the
  property, or in the code under test, will generate output in the
  shell as usual. This applies even to calls inside a
  <tt>?WHENFAIL</tt>, although this output can be redirected by replacing
  calls to <tt>io:format</tt> by calls to <tt>eqc:format/2</tt>. If you want
  to redirect output outside of <tt>?WHENFAIL</tt>, then you need to modify
  your own code appropriately.</p>
  <p>The reason that <tt>Fun</tt> is passed a format string and
  arguments, rather than an already formatted string, is to make it
  easier to extract information from the output without parsing
  it. However, there is no guarantee that different versions of
  QuickCheck will use the same format strings and term lists--you use
  this information at your own risk, in other words.</p></p>

<h3 class="function"><a name="on_test-2">on_test/2</a></h3>
<div class="spec">
<p><tt>on_test(Fun::fun((<a href="#type-counterexample">counterexample()</a>, bool()) -&gt; any()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Attaches a function to a property which is called every time a
  test passes or fails. The arguments are the test case (a list of
  values), and a boolean indicating whether or not the test
  passed. Tests which are skipped (because of an
  <tt>?IMPLIES(false,...)</tt>) are not included.</p>

<h3 class="function"><a name="only_top-1">only_top/1</a></h3>
<div class="spec">
<p><tt>only_top(N::integer()) -&gt; <a href="#type-print_method">print_method()</a></tt><br></p>
<p> </p>
</div><p>A printing method for discarding all but the top N collected values.
  Discarded values are grouped together into an entry labelled '...'. The
  resulting print method is intended to be passed to <a docgen-rel="seemfa" docgen-href="#collect/3" href="#collect-3"><code>collect/3</code></a> or
  <a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="function"><a name="only_top-2">only_top/2</a></h3>
<div class="spec">
<p><tt>only_top(N::integer(), F::<a href="#type-print_method">print_method()</a>) -&gt; <a href="#type-print_method">print_method()</a></tt><br></p>
<p> </p>
</div><p>A printing method for discarding all but the top N collected values.
  Discarded values are grouped together into an entry labelled '...'. The
  second argument is a print method for the pruned data, such as <a docgen-rel="seemfa" docgen-href="#with_title/1" href="#with_title-1"><code>with_title/1</code></a>. The resulting print method is intended to be passed to <a docgen-rel="seemfa" docgen-href="#collect/3" href="#collect-3"><code>collect/3</code></a> or <a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="function"><a name="quickcheck-1">quickcheck/1</a></h3>
<div class="spec">
<p><tt>quickcheck(P::<a href="#type-property">property()</a>) -&gt; bool()</tt><br></p>
<p> </p>
</div><p>Tests the property in 100 random cases, printing a counter-example
 if one is found. Initially small test cases are generated, then the
 size increases as testing progresses (see <a docgen-rel="seeerl" docgen-href="eqc_gen" href="eqc_gen.html"><code>eqc_gen</code></a>, <tt>?SIZED</tt>,
 <a docgen-rel="seemfa" docgen-href="eqc_gen#resize/2" href="eqc_gen.html#resize-2"><code>eqc_gen:resize/2</code></a> for the way size affects test data generation).
 The result is <tt>true</tt> if all tests succeeded (or if one failed,
 and failure was expected). On success, <tt>quickcheck</tt> analyses
 the distribution of test case labels. On failure, <tt>quickcheck</tt>
 tries to simplify the counter-example found as far as possible (see <i>
 shrinking</i>, described in <a docgen-rel="seeerl" docgen-href="eqc_gen" href="eqc_gen.html"><code>eqc_gen</code></a>).</p>

<h3 class="function"><a name="recheck-1">recheck/1</a></h3>
<div class="spec">
<p><tt>recheck(Prop::<a href="#type-property">property()</a>) -&gt; bool()</tt><br></p>
<p> </p>
</div><p>Tests the property with the <i>same</i> random number seed as
 the last failing call of <a docgen-rel="seemfa" docgen-href="#quickcheck/1" href="#quickcheck-1"><code>quickcheck/1</code></a>. If the property is
 the same as in that last call, then the same test case will be
 generated. Note that recheck repeats the test <i>and its
 shrinking</i>. This can be used to adjust the shrinking strategy in
 the property, then reshrink the same counterexample, perhaps to a
 better result. If you just
 want to repeat the <i>shrunk</i> test, then use
 <pre>eqc:check(Prop,eqc:counterexample())</pre> instead.</p>

<h3 class="function"><a name="recheck-2">recheck/2</a></h3>
<div class="spec">
<p><tt>recheck(Prop::<a href="#type-property">property()</a>, Options::[term()]) -&gt; boolean() | <a href="#type-eqc_info_map">eqc_info_map()</a></tt><br></p>
<p> </p>
</div><p>Same as <a docgen-rel="seemfa" docgen-href="#recheck/1" href="#recheck-1"><code>recheck/1</code></a>, but if {with_info, true} is passed as an option
 a richer structure is returned. See <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a> for a description of
 the return format.</p>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><tt>start() -&gt; pid()</tt><br></p>
<p> </p>
</div><p><p>Starts the QuickCheck server. If it is already running on this 
node, nothing is done.</p>

 Each user can run only one instance of the QuickCheck server at a
 time. If the server is already running on another Erlang node, it
 will be terminated automatically.</p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><tt>start(Dummy) -&gt; any()</tt></p>
<p> </p>
</div><p>Equivalent to <a href="#start-0"><tt>start()</tt></a>.</p>


<h3 class="function"><a name="stop-0">stop/0</a></h3>
<div class="spec">
<p><tt>stop() -&gt; any()</tt></p>
<p> </p>
</div><p>Stops the QuickCheck server.
 QuickCheck properties are tested in the QuickCheck server process, which is
 spawned automatically when quickcheck is first called. Usually there is no
 need to stop the QuickCheck server explicitly, but if a need does arise
 then this function can be used.</p>

<h3 class="function"><a name="user_info-3">user_info/3</a></h3>
<div class="spec">
<p><tt>user_info(Key::atom(), FunOrData::fun((any()) -&gt; any()), Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br></p>
<p> </p>
</div><p>Sometimes it is useful to record data deep inside a property, thus we
 provide a basic key-value store. Either some static piece of data can be
 stored for <tt>Key</tt>, if <tt>DataOrFun</tt> is not a function. Otherwise
 the function (with arity 1) in <tt>DataOrFun</tt> is applied to whatever data
 is stored for <tt>Key</tt>, if no data is yet stored the function is applied
 to <tt>undefined</tt>.
 <pre>
   prop_ok() -&gt;
     ?FORALL(X, nat(),
       user_info(sum, fun(undefined) -&gt; X; (Sum) -&gt; Sum + X end, ...)).
 </pre>
 If this property is tested with <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a> passing
 <tt>{with_info, true}</tt> as an option it will result in a result map where
 <tt>user_info</tt> is a map containing the key <tt>sum</tt> and the value
 will be the total sum of all tested values (including shrunk values if the
 property fails!). The rich result is further described for <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a>.</p>

<h3 class="function"><a name="version-0">version/0</a></h3>
<div class="spec">
<p><tt>version() -&gt; any()</tt></p>
<p> </p>
</div><p>Returns the version number of this version of QuickCheck.</p>

<h3 class="function"><a name="with_tag-1">with_tag/1</a></h3>
<div class="spec">
<p><tt>with_tag(Tag::atom() | string()) -&gt; <a href="#type-print_method">print_method()</a></tt><br></p>
<p> </p>
</div><p>A printing method for collected data, which tags the collected
  data so that it is returned in the rich result structure from
  <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a>. It is intended to be
  passed to <a docgen-rel="seemfa" docgen-href="#collect/3" href="#collect-3"><code>collect/3</code></a> or <a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>.</p>

<h3 class="function"><a name="with_title-1">with_title/1</a></h3>
<div class="spec">
<p><tt>with_title(Title::atom() | string()) -&gt; <a href="#type-print_method">print_method()</a></tt><br></p>
<p> </p>
</div><p><p>A printing method for collected data, which displays a title
  before the percentages of each value in the data. It is intended to be
  passed to <a docgen-rel="seemfa" docgen-href="#collect/3" href="#collect-3"><code>collect/3</code></a> or <a docgen-rel="seemfa" docgen-href="#aggregate/3" href="#aggregate-3"><code>aggregate/3</code></a>.</p>
 
  The function also tags the collected data (with the title) so that it
  is returned in the rich result structure from <a docgen-rel="seemfa" docgen-href="#counterexample/2" href="#counterexample-2"><code>counterexample/2</code></a>.</p>

<h3 class="function"><a name="with_title-2">with_title/2</a></h3>
<div class="spec">
<p><tt>with_title(Title::atom() | string(), Fun::<a href="#type-print_method">print_method()</a>) -&gt; <a href="#type-print_method">print_method()</a></tt><br></p>
<p> </p>
</div><p>Add a title to a print method. The title is printed before the print
  method is called.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
